)]}'
{"version": 3, "sources": ["/website/static/src/components/configurator/configurator.js"], "mappings": "AAAA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["/** @odoo-module **/\n\nimport rpc from 'web.rpc';\nimport utils from 'web.utils';\nimport weUtils from 'web_editor.utils';\nimport session from 'web.session';\nimport {ColorpickerWidget} from 'web.Colorpicker';\nimport {_t, _lt} from 'web.core';\nimport {svgToPNG} from 'website.utils';\nimport {useService} from \"@web/core/utils/hooks\";\n\nconst {Component, Store, mount, QWeb} = owl;\nconst {useDispatch, useStore, useGetters, useRef} = owl.hooks;\nconst {Router, RouteComponent} = owl.router;\nconst {whenReady} = owl.utils;\n\nconst WEBSITE_TYPES = {\n    1: {id: 1, label: _lt(\"a business website\"), name: 'business'},\n    2: {id: 2, label: _lt(\"an online store\"), name: 'online_store'},\n    3: {id: 3, label: _lt(\"a blog\"), name: 'blog'},\n    4: {id: 4, label: _lt(\"an event website\"), name: 'event'},\n    5: {id: 5, label: _lt(\"an elearning platform\"), name: 'elearning'}\n};\n\nconst WEBSITE_PURPOSES = {\n    1: {id: 1, label: _lt(\"get leads\"), name: 'get_leads'},\n    2: {id: 2, label: _lt(\"develop the brand\"), name: 'develop_brand'},\n    3: {id: 3, label: _lt(\"sell more\"), name: 'sell_more'},\n    4: {id: 4, label: _lt(\"inform customers\"), name: 'inform_customers'},\n    5: {id: 5, label: _lt(\"schedule appointments\"), name: 'schedule_appointments'}\n};\n\nconst PALETTE_NAMES = [\n    'default-1',\n    'default-2',\n    'default-3',\n    'default-4',\n    'default-5',\n    'default-6',\n    'default-7',\n    'default-8',\n    'default-9',\n    'default-10',\n    'default-11',\n    'default-12',\n    'default-13',\n    'default-14',\n    'default-15',\n    'default-16',\n    'default-17',\n    'default-18',\n    'default-19',\n    'default-20',\n];\n\n// Attributes for which background color should be retrieved\n// from CSS and added in each palette.\nconst CUSTOM_BG_COLOR_ATTRS = ['menu', 'footer'];\n\nconst SESSION_STORAGE_ITEM_NAME = 'websiteConfigurator' + session.website_id;\n\n//---------------------------------------------------------\n// Components\n//---------------------------------------------------------\n\nclass SkipButton extends Component {\n    async skip() {\n        await skipConfigurator(Component.env.services);\n    }\n}\n\nSkipButton.template = 'website.Configurator.SkipButton';\n\nclass WelcomeScreen extends Component {\n    constructor() {\n        super(...arguments);\n        this.dispatch = useDispatch();\n    }\n\n    goToDescription() {\n        this.env.router.navigate({to: 'CONFIGURATOR_DESCRIPTION_SCREEN'});\n    }\n}\n\nObject.assign(WelcomeScreen, {\n    components: {SkipButton},\n    template: 'website.Configurator.WelcomeScreen',\n});\n\nclass DescriptionScreen extends Component {\n    constructor() {\n        super(...arguments);\n        this.industrySelection = useRef('industrySelection');\n        this.state = useStore((state) => state);\n        this.labelToId = {};\n        this.getters = useGetters();\n        this.dispatch = useDispatch();\n        this.autocompleteHasResults = true;\n    }\n\n    mounted() {\n        this.dispatch('selectWebsitePurpose', undefined);\n        $(this.industrySelection.el).autocomplete({\n            appendTo: '.o_configurator_industry_wrapper',\n            delay: 400,\n            minLength: 1,\n            source: this._autocompleteSearch.bind(this),\n            select: this._selectIndustry.bind(this),\n            open: this._customizeNoResultMenuStyle.bind(this),\n            focus: this._disableKeyboardNav.bind(this),\n            classes: {\n                'ui-autocomplete': 'custom-ui-autocomplete shadow-lg border-0 o_configurator_show_fast',\n            }\n        });\n        if (this.state.selectedIndustry) {\n            this.industrySelection.el.value = this.state.selectedIndustry.label;\n            this.industrySelection.el.parentNode.dataset.value = this.state.selectedIndustry.label;\n            this.labelToId[this.state.selectedIndustry.label] = this.state.selectedIndustry.id;\n        }\n    }\n\n    /**\n     * Clear the input and its parent label and set the selected industry to undefined.\n     *\n     * @private\n     */\n    _clearIndustrySelection() {\n        this.industrySelection.el.value = '';\n        this.industrySelection.el.parentNode.dataset.value = '';\n        this.dispatch('selectIndustry', undefined, undefined);\n    }\n\n    /**\n     * Set the input's parent label value to automatically adapt input size\n     * and update the selected industry.\n     *\n     * @private\n     * @param {String} label an industry label\n     */\n    _setSelectedIndustry(label) {\n        this.industrySelection.el.parentNode.dataset.value = label;\n        const id = this.labelToId[label];\n        this.dispatch('selectIndustry', label, id);\n        this.checkDescriptionCompletion();\n    }\n\n    /**\n     * Called each time the suggestion menu is opened or updated. If there are no\n     * results to display the style of the \"No result found\" message is customized.\n     *\n     * @private\n     */\n    _customizeNoResultMenuStyle() {\n        if (!this.autocompleteHasResults) {\n            const noResultLinkEl = this.industrySelection.el.parentElement.getElementsByTagName('a')[0];\n            noResultLinkEl.classList.add('o_no_result');\n        }\n    }\n\n    /**\n     * Disables keyboard navigation when there are no results to avoid selecting the\n     * \"No result found\" message by pressing the down arrow key.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _disableKeyboardNav(ev) {\n        if (!this.autocompleteHasResults) {\n            ev.preventDefault();\n        }\n    }\n\n    /**\n     * Called each time the autocomplete input's value changes. Only industries containing\n     * the input value are kept. Industries starting with the input value are put in first\n     * position then the order is the alphabetical one. The result size is limited to 15.\n     *\n     * @param {Object} request object with a single 'term' property which is the input current value\n     * @param {function} response callback which takes the data to suggest as argument\n     */\n    _autocompleteSearch(request, response) {\n        const lcTerm = request.term.toLowerCase();\n        const limit = 15;\n        const matches = this.state.industries.filter((val) => {\n            return val.label.startsWith(lcTerm);\n        });\n        let results = matches.slice(0, limit);\n        this.labelToId = {};\n        let labels = results.map((val) => val.label);\n        if (labels.length < limit) {\n            let relaxedMatches = this.state.industries.filter((val) => {\n                return val.label.includes(lcTerm) && !labels.includes(val.label);\n            });\n            relaxedMatches = relaxedMatches.slice(0, limit - labels.length);\n            results = results.concat(relaxedMatches);\n        }\n        this.autocompleteHasResults = !!results.length;\n        if (this.autocompleteHasResults) {\n            labels = results.map((val) => val.label);\n            results.forEach((r) => {\n                this.labelToId[r.label] = r.id;\n            });\n        } else {\n            labels = [_t(\"No result found, broaden your search.\")];\n        }\n        response(labels);\n    }\n\n    /**\n     * Called when a menu option is selected. Update the selected industry or\n     * clear the input if the option is the \"No result found\" message.\n     *\n     * @private\n     * @param {Event} ev\n     * @param {Object} ui an object with label and value properties for\n     *      the selected option.\n     */\n    _selectIndustry(ev, ui) {\n        if (this.autocompleteHasResults) {\n            this._setSelectedIndustry(ui.item.label);\n        } else {\n            this._clearIndustrySelection();\n            ev.preventDefault();\n        }\n    }\n\n    /**\n     * Called on industrySelection input blur. Updates the selected industry or\n     * clears the input if its current value is not a valid industry.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _blurIndustrySelection(ev) {\n        if (this.labelToId[ev.target.value] !== undefined) {\n            this._setSelectedIndustry(ev.target.value);\n        } else {\n            this._clearIndustrySelection();\n        }\n    }\n\n    selectWebsiteType(ev) {\n        const {id} = ev.target.dataset;\n        this.dispatch('selectWebsiteType', id);\n        setTimeout(() => {\n            this.industrySelection.el.focus();\n        });\n        this.checkDescriptionCompletion();\n    }\n\n    selectWebsitePurpose(ev) {\n        const {id} = ev.target.dataset;\n        this.dispatch('selectWebsitePurpose', id);\n        this.checkDescriptionCompletion();\n    }\n\n    checkDescriptionCompletion() {\n        const {selectedType, selectedPurpose, selectedIndustry} = this.state;\n        if (selectedType && selectedPurpose && selectedIndustry) {\n            this.env.router.navigate({to: 'CONFIGURATOR_PALETTE_SELECTION_SCREEN'});\n        }\n    }\n}\n\nObject.assign(DescriptionScreen, {\n    components: {SkipButton},\n    template: 'website.Configurator.DescriptionScreen',\n});\n\nclass PaletteSelectionScreen extends Component {\n    constructor() {\n        super(...arguments);\n        this.state = useStore((state) => state);\n        this.getters = useGetters();\n        this.dispatch = useDispatch();\n        this.logoInputRef = useRef('logoSelectionInput');\n        this.notification = useService(\"notification\");\n    }\n\n    mounted() {\n        if (this.state.logo) {\n            this.updatePalettes();\n        }\n    }\n\n    uploadLogo() {\n        this.logoInputRef.el.click();\n    }\n\n    async changeLogo() {\n        const logoSelectInput = this.logoInputRef.el;\n        if (logoSelectInput.files.length === 1) {\n            const file = logoSelectInput.files[0];\n            const data = await utils.getDataURLFromFile(file);\n            const attachment = await this.rpc({\n                route: '/web_editor/attachment/add_data',\n                params: {\n                    name: 'logo',\n                    data: data.split(',')[1],\n                    is_image: true,\n                }\n            });\n            if (!attachment.error) {\n                this.dispatch('changeLogo', data, attachment.id);\n                this.updatePalettes();\n            } else {\n                this.notification.notify({\n                    title: file.name,\n                    message: attachment.error,\n                });\n            }\n        }\n    }\n\n    async updatePalettes() {\n        let img = this.state.logo;\n        if (img.startsWith('data:image/svg+xml')) {\n            img = await svgToPNG(img);\n        }\n        img = img.split(',')[1];\n        const [color1, color2] = await this.rpc({\n            model: 'base.document.layout',\n            method: 'extract_image_primary_secondary_colors',\n            args: [img],\n            kwargs: {mitigate: 255},\n        });\n        this.dispatch('setRecommendedPalette', color1, color2);\n    }\n\n    selectPalette(paletteName) {\n        this.dispatch('selectPalette', paletteName);\n        this.env.router.navigate({to: 'CONFIGURATOR_FEATURES_SELECTION_SCREEN'});\n    }\n}\n\nObject.assign(PaletteSelectionScreen, {\n    components: {SkipButton},\n    template: 'website.Configurator.PaletteSelectionScreen',\n});\n\nclass FeaturesSelectionScreen extends Component {\n    constructor() {\n        super(...arguments);\n        this.state = useStore((state) => state);\n        this.getters = useGetters();\n        this.dispatch = useDispatch();\n    }\n\n    async buildWebsite() {\n        const industryId = this.state.selectedIndustry && this.state.selectedIndustry.id;\n        if (!industryId) {\n            this.env.router.navigate({to: 'CONFIGURATOR_DESCRIPTION_SCREEN'});\n            return;\n        }\n        const params = {\n            industry_id: industryId,\n            palette: this.state.selectedPalette\n        };\n        const themes = await this.rpc({\n            model: 'website',\n            method: 'configurator_recommended_themes',\n            kwargs: params,\n        });\n\n        if (!themes.length) {\n            await applyConfigurator(this, 'theme_default');\n        } else {\n            this.dispatch('updateRecommendedThemes', themes);\n            this.env.router.navigate({to: 'CONFIGURATOR_THEME_SELECTION_SCREEN'});\n        }\n    }\n}\n\nObject.assign(FeaturesSelectionScreen, {\n    components: {SkipButton},\n    template: 'website.Configurator.FeatureSelection',\n});\n\nclass ThemeSelectionScreen extends Component {\n    constructor() {\n        super(...arguments);\n        this.state = useStore((state) => state);\n        this.getters = useGetters();\n        this.themeSVGPreviews = [useRef('ThemePreview1'), useRef('ThemePreview2'), useRef('ThemePreview3')];\n    }\n\n    mounted() {\n        this.state.themes.forEach((theme, idx) => {\n            $(this.themeSVGPreviews[idx].el).append(theme.svg);\n        });\n    }\n\n    async chooseTheme(themeName) {\n        await applyConfigurator(this, themeName);\n    }\n}\n\nThemeSelectionScreen.template = 'website.Configurator.ThemeSelectionScreen';\n\nclass App extends Component {}\n\nObject.assign(App, {\n    components: {RouteComponent},\n    template: 'website.Configurator.App',\n});\n\n//---------------------------------------------------------\n// Routes\n//---------------------------------------------------------\n\nconst ROUTES = [\n    {name: 'CONFIGURATOR_WELCOME_SCREEN', path: '/website/configurator', component: WelcomeScreen},\n    {name: 'CONFIGURATOR_WELCOME_SCREEN_FALLBACK', path: '/website/configurator/1', component: WelcomeScreen},\n    {name: 'CONFIGURATOR_DESCRIPTION_SCREEN', path: '/website/configurator/2', component: DescriptionScreen},\n    {name: 'CONFIGURATOR_PALETTE_SELECTION_SCREEN', path: '/website/configurator/3', component: PaletteSelectionScreen},\n    {name: 'CONFIGURATOR_FEATURES_SELECTION_SCREEN', path: '/website/configurator/4', component: FeaturesSelectionScreen},\n    {name: 'CONFIGURATOR_THEME_SELECTION_SCREEN', path: '/website/configurator/5', component: ThemeSelectionScreen},\n];\n\n//---------------------------------------------------------\n// Store\n//---------------------------------------------------------\n\nconst getters = {\n    getWebsiteTypes() {\n        return Object.values(WEBSITE_TYPES);\n    },\n\n    getSelectedType(_, id) {\n        return id ? WEBSITE_TYPES[id] : undefined;\n    },\n\n    getWebsitePurpose() {\n        return Object.values(WEBSITE_PURPOSES);\n    },\n\n    getSelectedPurpose(_, id) {\n        return id ? WEBSITE_PURPOSES[id] : undefined;\n    },\n\n    getFeatures({state}) {\n        return Object.values(state.features);\n    },\n\n    getPalettes({state}) {\n        return Object.values(state.palettes);\n    },\n\n    getThemeName({state}, idx) {\n        return state.themes.length > idx ? state.themes[idx].name : undefined;\n    },\n    /**\n     * @param {Object} obj\n     * @param {string|undefined} [obj.state]\n     * @returns {string|false}\n     */\n    getSelectedPaletteName({state}) {\n        const palette = state.selectedPalette;\n        return palette ? (palette.name || 'recommendedPalette') : false;\n    },\n};\n\nconst actions = {\n    selectWebsiteType({state}, id) {\n        Object.values(state.features).filter((feature) => feature.module_state !== 'installed').forEach((feature) => {\n            feature.selected = feature.website_config_preselection.includes(WEBSITE_TYPES[id].name);\n        });\n        state.selectedType = id;\n    },\n    selectWebsitePurpose({state}, id) {\n        Object.values(state.features).filter((feature) => feature.module_state !== 'installed').forEach((feature) => {\n            // need to check id, since we set to undefined in mount() to avoid the auto next screen on back button\n            feature.selected |= id && feature.website_config_preselection.includes(WEBSITE_PURPOSES[id].name);\n        });\n        state.selectedPurpose = id;\n    },\n    selectIndustry({state}, label, id) {\n        if (!label || !id) {\n            state.selectedIndustry = undefined;\n        } else {\n            state.selectedIndustry = {id, label};\n        }\n    },\n    changeLogo({state}, data, attachmentId) {\n        state.logo = data;\n        state.logoAttachmentId = attachmentId;\n    },\n    selectPalette({state}, paletteName) {\n        if (paletteName === 'recommendedPalette') {\n            state.selectedPalette = state.recommendedPalette;\n        } else {\n            state.selectedPalette = state.palettes[paletteName];\n        }\n    },\n    toggleFeature({state}, featureId) {\n        const feature = state.features[featureId];\n        const isModuleInstalled = feature.module_state === 'installed';\n        feature.selected = !feature.selected || isModuleInstalled;\n    },\n    setRecommendedPalette({state}, color1, color2) {\n        if (color1 && color2) {\n            if (color1 === color2) {\n                color2 = ColorpickerWidget.mixCssColors('#FFFFFF', color1, 0.2);\n            }\n            const recommendedPalette = {\n                color1: color1,\n                color2: color2,\n                color3: ColorpickerWidget.mixCssColors('#FFFFFF', color2, 0.9),\n                color4: '#FFFFFF',\n                color5: ColorpickerWidget.mixCssColors(color1, '#000000', 0.75),\n            };\n            CUSTOM_BG_COLOR_ATTRS.forEach((attr) => {\n                recommendedPalette[attr] = recommendedPalette[state.defaultColors[attr]];\n            });\n            state.recommendedPalette = recommendedPalette;\n        } else {\n            state.recommendedPalette = undefined;\n        }\n    },\n    updateRecommendedThemes({state}, themes) {\n        state.themes = themes.slice(0, 3);\n    }\n};\n\nasync function getInitialState(services) {\n\n    // Load values from python and iap\n    var results = await services.rpc({\n        model: 'website',\n        method: 'configurator_init',\n    });\n    const r = {\n        industries: results.industries,\n        logo: results.logo ? 'data:image/png;base64,' + results.logo : false,\n    };\n\n    // Load palettes from the current CSS\n    const palettes = {};\n    const style = window.getComputedStyle(document.documentElement);\n\n    PALETTE_NAMES.forEach((paletteName) => {\n        const palette = {\n            name: paletteName\n        };\n        for (let j = 1; j <= 5; j += 1) {\n            palette[`color${j}`] = weUtils.getCSSVariableValue(`o-palette-${paletteName}-o-color-${j}`, style);\n        }\n        CUSTOM_BG_COLOR_ATTRS.forEach((attr) => {\n            palette[attr] = weUtils.getCSSVariableValue(`o-palette-${paletteName}-${attr}-bg`, style);\n        });\n        palettes[paletteName] = palette;\n    });\n\n    const localState = JSON.parse(window.sessionStorage.getItem(SESSION_STORAGE_ITEM_NAME));\n    if (localState) {\n        let themes = [];\n        if (localState.selectedIndustry && localState.selectedPalette) {\n            const params = {\n                industry_id: localState.selectedIndustry.id,\n                palette: localState.selectedPalette\n            };\n            themes = await services.rpc({\n                model: 'website',\n                method: 'configurator_recommended_themes',\n                kwargs: params,\n            });\n        }\n        return Object.assign(r, {...localState, palettes, themes});\n    }\n\n    const features = {};\n    results.features.forEach(feature => {\n        features[feature.id] = Object.assign({}, feature, {selected: feature.module_state === 'installed'});\n        const wtp = features[feature.id].website_config_preselection;\n        features[feature.id].website_config_preselection = wtp ? wtp.split(',') : [];\n    });\n\n    // Palette color used by default as background color for menu and footer.\n    // Needed to build the recommended palette.\n    const defaultColors = {};\n    CUSTOM_BG_COLOR_ATTRS.forEach((attr) => {\n        const color = weUtils.getCSSVariableValue(`o-default-${attr}-bg`, style);\n        const match = color.match(/o-color-(?<idx>[1-5])/);\n        const colorIdx = parseInt(match.groups['idx']);\n        defaultColors[attr] = `color${colorIdx}`;\n    });\n\n    return Object.assign(r, {\n        selectedType: undefined,\n        selectedPurpose: undefined,\n        selectedIndustry: undefined,\n        selectedPalette: undefined,\n        recommendedPalette: undefined,\n        defaultColors: defaultColors,\n        palettes: palettes,\n        features: features,\n        themes: [],\n        logoAttachmentId: undefined,\n    });\n}\n\nasync function skipConfigurator(services) {\n    await services.rpc({\n        model: 'website',\n        method: 'configurator_skip',\n    });\n    window.sessionStorage.removeItem(SESSION_STORAGE_ITEM_NAME);\n    window.location = '/web#action=website.theme_install_kanban_action';\n}\n\nasync function applyConfigurator(self, themeName) {\n    if (!self.state.selectedIndustry) {\n        self.env.router.navigate({to: 'CONFIGURATOR_DESCRIPTION_SCREEN'});\n        return;\n    }\n    if (!self.state.selectedPalette) {\n        self.env.router.navigate({to: 'CONFIGURATOR_PALETTE_SELECTION_SCREEN'});\n        return;\n    }\n    if (themeName !== undefined) {\n        $('body').append(self.env.loader);\n        const selectedFeatures = Object.values(self.state.features).filter((feature) => feature.selected).map((feature) => feature.id);\n        let selectedPalette = self.state.selectedPalette.name;\n        if (!selectedPalette) {\n            selectedPalette = [\n                self.state.selectedPalette.color1,\n                self.state.selectedPalette.color2,\n                self.state.selectedPalette.color3,\n                self.state.selectedPalette.color4,\n                self.state.selectedPalette.color5,\n            ];\n        }\n        const data = {\n            selected_features: selectedFeatures,\n            industry_id: self.state.selectedIndustry.id,\n            selected_palette: selectedPalette,\n            theme_name: themeName,\n            website_purpose: WEBSITE_PURPOSES[self.state.selectedPurpose].name,\n            website_type: WEBSITE_TYPES[self.state.selectedType].name,\n            logo_attachment_id: self.state.logoAttachmentId,\n        };\n        const resp = await self.rpc({\n            model: 'website',\n            method: 'configurator_apply',\n            kwargs: {...data},\n        });\n        window.sessionStorage.removeItem(SESSION_STORAGE_ITEM_NAME);\n        window.location = resp.url;\n    }\n}\n\nasync function makeEnvironment() {\n    const env = {};\n    const router = new Router(env, ROUTES);\n    await router.start();\n    const services = Component.env.services;\n    const state = await getInitialState(services);\n    const store = new Store({state, actions, getters});\n    store.on(\"update\", null, () => {\n        const newState = {\n            selectedType: store.state.selectedType,\n            selectedPurpose: store.state.selectedPurpose,\n            selectedIndustry: store.state.selectedIndustry,\n            selectedPalette: store.state.selectedPalette,\n            recommendedPalette: store.state.recommendedPalette,\n            defaultColors: store.state.defaultColors,\n            features: store.state.features,\n            logo: store.state.logo,\n            logoAttachmentId: store.state.logoAttachmentId,\n        };\n        window.sessionStorage.setItem(SESSION_STORAGE_ITEM_NAME, JSON.stringify(newState));\n    });\n    await session.is_bound;\n    const qweb = new QWeb({translateFn: _t});\n    const loaderTemplate = await owl.utils.loadFile('/website/static/src/xml/theme_preview.xml');\n    const configuratorTemplates = await owl.utils.loadFile('/website/static/src/components/configurator/configurator.xml');\n    qweb.addTemplates(loaderTemplate);\n    qweb.addTemplates(configuratorTemplates);\n\n    env.loader = qweb.renderToString('website.ThemePreview.Loader', {\n        showTips: true\n    });\n    return Object.assign(env, {router, store, qweb, services});\n}\n\nasync function setup() {\n    const env = await makeEnvironment();\n    if (!env.store.state.industries) {\n        await skipConfigurator(env.services);\n    } else {\n        mount(App, {target: document.body, env});\n    }\n}\n\nwhenReady(setup);\n"], "file": "/web/assets/858-cd6c399/1/website.website_configurator_assets_js.js", "sourceRoot": "../../../../"}